"""
RIT Market Simulator Algorithmic ETF Arbitrage Case - Support File
Rotman BMO Finance Research and Trading Lab, Uniersity of Toronto (C)
All rights reserved.
"""

import requests
from time import sleep
import numpy as np
import arbTrading as arb

'''
If you are not familiar with Python or feeling a little bit rusty, highly recommend you to go through the following link:
    https://github.com/trekhleb/learn-python

If you have any question about REST APIs and outputs of code please read:
    https://realpython.com/api-integration-in-python/#http-methods
    https://rit.306w.ca/RIT-REST-API/1.0.3/?port=9999&key=Rotman#/

So basciallyï¼š
The core of this case is to design algorithmic trading strategies that exploit arbitrage opportunities between the ETF (RITC) 
and its underlying stocks (BULL and BEAR), while effectively using tender offers and conversion tools to avoid speculative risk
and maximize returns.
'''

API = "http://localhost:9999/v1"
API_KEY = "WILL"                     # <-- your key
HDRS = {"X-API-key": API_KEY}          # change to X-API-Key if your server needs it

# Tickers
CAD  = "CAD"    # currency instrument quoted in CAD
USD  = "USD"    # price of 1 USD in CAD (i.e., USD/CAD)
BULL = "BULL"   # stock in CAD
BEAR = "BEAR"   # stock in CAD
RITC = "RITC"   # ETF quoted in USD

# Per problem statement
FEE_MKT = 0.02           # $/share (market)
REBATE_LMT = 0.01        # $/share (passive) - not used in this baseline
MAX_SIZE_EQUITY = 10000 # per order for BULL/BEAR/RITC
MAX_SIZE_FX = 2500000  # per order for CAD/USD

# Basic risk guardrails (adjust as needed)
MAX_LONG_NET  = 25000
MAX_SHORT_NET = -25000
MAX_GROSS     = 500000
ORDER_QTY     = 5000    # child order size for arb legs

# Cushion to beat fees & slippage.
# 3 legs with market orders => ~0.06 CAD/sh cost; add a bit more for safety.
ARB_THRESHOLD_CAD = 0.07

# --------- SESSION ----------
s = requests.Session()
s.headers.update(HDRS)

# --------- HELPERS ----------
def get_tick_status():
    # Gets simulation status (active or stopped) for the tick
    r = s.get(f"{API}/case")
    r.raise_for_status()
    j = r.json()
    return j["tick"], j["status"]

def best_bid_ask(ticker):
    # Returns best bid and ask prices for a ticker
    r = s.get(f"{API}/securities/book", params={"ticker": ticker})
    r.raise_for_status()
    book = r.json()
    'Why choose [0] here, not [1]? Is the price for bids and asks also generated by r'
    bid = float(book["bids"][0]["price"]) if book["bids"] else 0.0
    ask = float(book["asks"][0]["price"]) if book["asks"] else 1e12
    return bid, ask

def positions_map():
    # Tracks current positions (number of shares currently hold for a ticker/instrument), to help risk management
    r = s.get(f"{API}/securities") # after switching /positions to /securities, no error popup.
    r.raise_for_status()
    out = {p["ticker"]: int(p.get("position", 0)) for p in r.json()}
    for k in (BULL, BEAR, RITC, USD, CAD):
        out.setdefault(k, 0)
    return out

def place_mkt(ticker, action, qty): # type LMT?
    # Sends Market orders; price param is ignored by most RIT cases when type=MARKET
    if qty > 10000:
        while(qty > 10000):
            s.post(f"{API}/orders",
                  params={"ticker": ticker, "type": "MARKET",
                          "quantity": 10000, "action": action}).ok
            qty -= 10000
    s.post(f"{API}/orders",
                  params={"ticker": ticker, "type": "MARKET",
                          "quantity": int(qty), "action": action}).ok

def within_limits():
    # Simple gross/net guard using equity legs only
    pos = positions_map()
    gross = abs(pos[BULL]) + abs(pos[BEAR]) + abs(pos[RITC])
    net   = pos[BULL] + pos[BEAR] + pos[RITC]  # simple net; refine as desired
    return (gross < MAX_GROSS) and (MAX_SHORT_NET < net < MAX_LONG_NET)

def accept_active_tender_offers():
    # Retrieve active tender offers from the RIT API, and accept the offer
    r = s.get(f"{API}/tenders")  # replace with the correct endpoint
    r.raise_for_status()
    offers = r.json()
        
    if offers:
        tender_id = offers[0]['tender_id']
        price = offers[0]['price']
        if offers[0]['is_fixed_bid']:
            resp = s.post(f"{API}/tenders/{tender_id}")
        else:
            resp = s.post(f"{API}/tenders/{tender_id}", params={"price": price})
        return print("Tender Offer Accepted:", resp.ok)
    print("No active tenders")
    
def get_positions(session):
        """Get current positions for all securities"""
        r = session.get("http://localhost:9999/v1/securities")
        r.raise_for_status()
        securities = r.json()
        
        positions = {}
        for sec in securities:
            ticker = sec["ticker"]
            positions[ticker] = int(sec.get("position", 0))
            
        # Ensure all tickers are present
        for ticker in [BULL, BEAR, RITC, USD, CAD]:
            positions.setdefault(ticker, 0)
            
        return positions

# --------- CORE LOGIC ----------
def step_once():
    positions = get_positions(s)
    print("Current Positions:", positions)
    for ticker in positions:
        shares = positions[ticker]
        if shares > 0:
            # Sell all long positions
            place_mkt(ticker, "SELL", shares)
        elif shares < 0:
            # Cover all short positions by buying back
            place_mkt(ticker, "BUY", abs(shares))


def main():
    tick = get_tick_status()
    trade = True
    while trade == True:
        step_once()
        # Optional: print a lightweight heartbeat every 1s
        #print(f"tick={tick} e1={e1:.4f} e2={e2:.4f} ritc_ask_cad={info['ritc_ask_cad']:.4f}")
        sleep(0.5)
        trade = False

if __name__ == "__main__":
    main()